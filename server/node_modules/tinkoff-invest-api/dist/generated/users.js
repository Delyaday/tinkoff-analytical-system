import _m0 from "protobufjs/minimal.js";
import { MoneyValue, Quotation } from "./common.js";
import { Timestamp } from "./google/protobuf/timestamp.js";
export const protobufPackage = "tinkoff.public.invest.api.contract.v1";
/** Тип счёта. */
export var AccountType;
(function (AccountType) {
    /** ACCOUNT_TYPE_UNSPECIFIED - Тип аккаунта не определён. */
    AccountType[AccountType["ACCOUNT_TYPE_UNSPECIFIED"] = 0] = "ACCOUNT_TYPE_UNSPECIFIED";
    /** ACCOUNT_TYPE_TINKOFF - Брокерский счёт Т-Инвестиций. */
    AccountType[AccountType["ACCOUNT_TYPE_TINKOFF"] = 1] = "ACCOUNT_TYPE_TINKOFF";
    /** ACCOUNT_TYPE_TINKOFF_IIS - ИИС. */
    AccountType[AccountType["ACCOUNT_TYPE_TINKOFF_IIS"] = 2] = "ACCOUNT_TYPE_TINKOFF_IIS";
    /** ACCOUNT_TYPE_INVEST_BOX - Инвесткопилка. */
    AccountType[AccountType["ACCOUNT_TYPE_INVEST_BOX"] = 3] = "ACCOUNT_TYPE_INVEST_BOX";
    /** ACCOUNT_TYPE_INVEST_FUND - Фонд денежного рынка. */
    AccountType[AccountType["ACCOUNT_TYPE_INVEST_FUND"] = 4] = "ACCOUNT_TYPE_INVEST_FUND";
    AccountType[AccountType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AccountType || (AccountType = {}));
export function accountTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "ACCOUNT_TYPE_UNSPECIFIED":
            return AccountType.ACCOUNT_TYPE_UNSPECIFIED;
        case 1:
        case "ACCOUNT_TYPE_TINKOFF":
            return AccountType.ACCOUNT_TYPE_TINKOFF;
        case 2:
        case "ACCOUNT_TYPE_TINKOFF_IIS":
            return AccountType.ACCOUNT_TYPE_TINKOFF_IIS;
        case 3:
        case "ACCOUNT_TYPE_INVEST_BOX":
            return AccountType.ACCOUNT_TYPE_INVEST_BOX;
        case 4:
        case "ACCOUNT_TYPE_INVEST_FUND":
            return AccountType.ACCOUNT_TYPE_INVEST_FUND;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AccountType.UNRECOGNIZED;
    }
}
export function accountTypeToJSON(object) {
    switch (object) {
        case AccountType.ACCOUNT_TYPE_UNSPECIFIED:
            return "ACCOUNT_TYPE_UNSPECIFIED";
        case AccountType.ACCOUNT_TYPE_TINKOFF:
            return "ACCOUNT_TYPE_TINKOFF";
        case AccountType.ACCOUNT_TYPE_TINKOFF_IIS:
            return "ACCOUNT_TYPE_TINKOFF_IIS";
        case AccountType.ACCOUNT_TYPE_INVEST_BOX:
            return "ACCOUNT_TYPE_INVEST_BOX";
        case AccountType.ACCOUNT_TYPE_INVEST_FUND:
            return "ACCOUNT_TYPE_INVEST_FUND";
        case AccountType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/** Статус счёта. */
export var AccountStatus;
(function (AccountStatus) {
    /** ACCOUNT_STATUS_UNSPECIFIED - Статус счёта не определён. */
    AccountStatus[AccountStatus["ACCOUNT_STATUS_UNSPECIFIED"] = 0] = "ACCOUNT_STATUS_UNSPECIFIED";
    /** ACCOUNT_STATUS_NEW - Новый, в процессе открытия. */
    AccountStatus[AccountStatus["ACCOUNT_STATUS_NEW"] = 1] = "ACCOUNT_STATUS_NEW";
    /** ACCOUNT_STATUS_OPEN - Открытый и активный счёт. */
    AccountStatus[AccountStatus["ACCOUNT_STATUS_OPEN"] = 2] = "ACCOUNT_STATUS_OPEN";
    /** ACCOUNT_STATUS_CLOSED - Закрытый счёт. */
    AccountStatus[AccountStatus["ACCOUNT_STATUS_CLOSED"] = 3] = "ACCOUNT_STATUS_CLOSED";
    /** ACCOUNT_STATUS_ALL - Все счета. */
    AccountStatus[AccountStatus["ACCOUNT_STATUS_ALL"] = 4] = "ACCOUNT_STATUS_ALL";
    AccountStatus[AccountStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AccountStatus || (AccountStatus = {}));
export function accountStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "ACCOUNT_STATUS_UNSPECIFIED":
            return AccountStatus.ACCOUNT_STATUS_UNSPECIFIED;
        case 1:
        case "ACCOUNT_STATUS_NEW":
            return AccountStatus.ACCOUNT_STATUS_NEW;
        case 2:
        case "ACCOUNT_STATUS_OPEN":
            return AccountStatus.ACCOUNT_STATUS_OPEN;
        case 3:
        case "ACCOUNT_STATUS_CLOSED":
            return AccountStatus.ACCOUNT_STATUS_CLOSED;
        case 4:
        case "ACCOUNT_STATUS_ALL":
            return AccountStatus.ACCOUNT_STATUS_ALL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AccountStatus.UNRECOGNIZED;
    }
}
export function accountStatusToJSON(object) {
    switch (object) {
        case AccountStatus.ACCOUNT_STATUS_UNSPECIFIED:
            return "ACCOUNT_STATUS_UNSPECIFIED";
        case AccountStatus.ACCOUNT_STATUS_NEW:
            return "ACCOUNT_STATUS_NEW";
        case AccountStatus.ACCOUNT_STATUS_OPEN:
            return "ACCOUNT_STATUS_OPEN";
        case AccountStatus.ACCOUNT_STATUS_CLOSED:
            return "ACCOUNT_STATUS_CLOSED";
        case AccountStatus.ACCOUNT_STATUS_ALL:
            return "ACCOUNT_STATUS_ALL";
        case AccountStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/** Уровень доступа к счёту. */
export var AccessLevel;
(function (AccessLevel) {
    /** ACCOUNT_ACCESS_LEVEL_UNSPECIFIED - Уровень доступа не определён. */
    AccessLevel[AccessLevel["ACCOUNT_ACCESS_LEVEL_UNSPECIFIED"] = 0] = "ACCOUNT_ACCESS_LEVEL_UNSPECIFIED";
    /** ACCOUNT_ACCESS_LEVEL_FULL_ACCESS - Полный доступ к счёту. */
    AccessLevel[AccessLevel["ACCOUNT_ACCESS_LEVEL_FULL_ACCESS"] = 1] = "ACCOUNT_ACCESS_LEVEL_FULL_ACCESS";
    /** ACCOUNT_ACCESS_LEVEL_READ_ONLY - Доступ с уровнем прав «только чтение». */
    AccessLevel[AccessLevel["ACCOUNT_ACCESS_LEVEL_READ_ONLY"] = 2] = "ACCOUNT_ACCESS_LEVEL_READ_ONLY";
    /** ACCOUNT_ACCESS_LEVEL_NO_ACCESS - Доступа нет. */
    AccessLevel[AccessLevel["ACCOUNT_ACCESS_LEVEL_NO_ACCESS"] = 3] = "ACCOUNT_ACCESS_LEVEL_NO_ACCESS";
    AccessLevel[AccessLevel["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AccessLevel || (AccessLevel = {}));
export function accessLevelFromJSON(object) {
    switch (object) {
        case 0:
        case "ACCOUNT_ACCESS_LEVEL_UNSPECIFIED":
            return AccessLevel.ACCOUNT_ACCESS_LEVEL_UNSPECIFIED;
        case 1:
        case "ACCOUNT_ACCESS_LEVEL_FULL_ACCESS":
            return AccessLevel.ACCOUNT_ACCESS_LEVEL_FULL_ACCESS;
        case 2:
        case "ACCOUNT_ACCESS_LEVEL_READ_ONLY":
            return AccessLevel.ACCOUNT_ACCESS_LEVEL_READ_ONLY;
        case 3:
        case "ACCOUNT_ACCESS_LEVEL_NO_ACCESS":
            return AccessLevel.ACCOUNT_ACCESS_LEVEL_NO_ACCESS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AccessLevel.UNRECOGNIZED;
    }
}
export function accessLevelToJSON(object) {
    switch (object) {
        case AccessLevel.ACCOUNT_ACCESS_LEVEL_UNSPECIFIED:
            return "ACCOUNT_ACCESS_LEVEL_UNSPECIFIED";
        case AccessLevel.ACCOUNT_ACCESS_LEVEL_FULL_ACCESS:
            return "ACCOUNT_ACCESS_LEVEL_FULL_ACCESS";
        case AccessLevel.ACCOUNT_ACCESS_LEVEL_READ_ONLY:
            return "ACCOUNT_ACCESS_LEVEL_READ_ONLY";
        case AccessLevel.ACCOUNT_ACCESS_LEVEL_NO_ACCESS:
            return "ACCOUNT_ACCESS_LEVEL_NO_ACCESS";
        case AccessLevel.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseGetAccountsRequest() {
    return { status: undefined };
}
export const GetAccountsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.status !== undefined) {
            writer.uint32(8).int32(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAccountsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { status: isSet(object.status) ? accountStatusFromJSON(object.status) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.status !== undefined) {
            obj.status = accountStatusToJSON(message.status);
        }
        return obj;
    },
};
function createBaseGetAccountsResponse() {
    return { accounts: [] };
}
export const GetAccountsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.accounts) {
            Account.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAccountsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.accounts.push(Account.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            accounts: globalThis.Array.isArray(object?.accounts) ? object.accounts.map((e) => Account.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.accounts?.length) {
            obj.accounts = message.accounts.map((e) => Account.toJSON(e));
        }
        return obj;
    },
};
function createBaseAccount() {
    return { id: "", type: 0, name: "", status: 0, openedDate: undefined, closedDate: undefined, accessLevel: 0 };
}
export const Account = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.type !== 0) {
            writer.uint32(16).int32(message.type);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.status !== 0) {
            writer.uint32(32).int32(message.status);
        }
        if (message.openedDate !== undefined) {
            Timestamp.encode(toTimestamp(message.openedDate), writer.uint32(42).fork()).ldelim();
        }
        if (message.closedDate !== undefined) {
            Timestamp.encode(toTimestamp(message.closedDate), writer.uint32(50).fork()).ldelim();
        }
        if (message.accessLevel !== 0) {
            writer.uint32(56).int32(message.accessLevel);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccount();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.openedDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.closedDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.accessLevel = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            type: isSet(object.type) ? accountTypeFromJSON(object.type) : 0,
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            status: isSet(object.status) ? accountStatusFromJSON(object.status) : 0,
            openedDate: isSet(object.openedDate) ? fromJsonTimestamp(object.openedDate) : undefined,
            closedDate: isSet(object.closedDate) ? fromJsonTimestamp(object.closedDate) : undefined,
            accessLevel: isSet(object.accessLevel) ? accessLevelFromJSON(object.accessLevel) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.type !== 0) {
            obj.type = accountTypeToJSON(message.type);
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.status !== 0) {
            obj.status = accountStatusToJSON(message.status);
        }
        if (message.openedDate !== undefined) {
            obj.openedDate = message.openedDate.toISOString();
        }
        if (message.closedDate !== undefined) {
            obj.closedDate = message.closedDate.toISOString();
        }
        if (message.accessLevel !== 0) {
            obj.accessLevel = accessLevelToJSON(message.accessLevel);
        }
        return obj;
    },
};
function createBaseGetMarginAttributesRequest() {
    return { accountId: "" };
}
export const GetMarginAttributesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.accountId !== "") {
            writer.uint32(10).string(message.accountId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetMarginAttributesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.accountId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.accountId !== "") {
            obj.accountId = message.accountId;
        }
        return obj;
    },
};
function createBaseGetMarginAttributesResponse() {
    return {
        liquidPortfolio: undefined,
        startingMargin: undefined,
        minimalMargin: undefined,
        fundsSufficiencyLevel: undefined,
        amountOfMissingFunds: undefined,
        correctedMargin: undefined,
    };
}
export const GetMarginAttributesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.liquidPortfolio !== undefined) {
            MoneyValue.encode(message.liquidPortfolio, writer.uint32(10).fork()).ldelim();
        }
        if (message.startingMargin !== undefined) {
            MoneyValue.encode(message.startingMargin, writer.uint32(18).fork()).ldelim();
        }
        if (message.minimalMargin !== undefined) {
            MoneyValue.encode(message.minimalMargin, writer.uint32(26).fork()).ldelim();
        }
        if (message.fundsSufficiencyLevel !== undefined) {
            Quotation.encode(message.fundsSufficiencyLevel, writer.uint32(34).fork()).ldelim();
        }
        if (message.amountOfMissingFunds !== undefined) {
            MoneyValue.encode(message.amountOfMissingFunds, writer.uint32(42).fork()).ldelim();
        }
        if (message.correctedMargin !== undefined) {
            MoneyValue.encode(message.correctedMargin, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetMarginAttributesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.liquidPortfolio = MoneyValue.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.startingMargin = MoneyValue.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.minimalMargin = MoneyValue.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.fundsSufficiencyLevel = Quotation.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.amountOfMissingFunds = MoneyValue.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.correctedMargin = MoneyValue.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            liquidPortfolio: isSet(object.liquidPortfolio) ? MoneyValue.fromJSON(object.liquidPortfolio) : undefined,
            startingMargin: isSet(object.startingMargin) ? MoneyValue.fromJSON(object.startingMargin) : undefined,
            minimalMargin: isSet(object.minimalMargin) ? MoneyValue.fromJSON(object.minimalMargin) : undefined,
            fundsSufficiencyLevel: isSet(object.fundsSufficiencyLevel)
                ? Quotation.fromJSON(object.fundsSufficiencyLevel)
                : undefined,
            amountOfMissingFunds: isSet(object.amountOfMissingFunds)
                ? MoneyValue.fromJSON(object.amountOfMissingFunds)
                : undefined,
            correctedMargin: isSet(object.correctedMargin) ? MoneyValue.fromJSON(object.correctedMargin) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.liquidPortfolio !== undefined) {
            obj.liquidPortfolio = MoneyValue.toJSON(message.liquidPortfolio);
        }
        if (message.startingMargin !== undefined) {
            obj.startingMargin = MoneyValue.toJSON(message.startingMargin);
        }
        if (message.minimalMargin !== undefined) {
            obj.minimalMargin = MoneyValue.toJSON(message.minimalMargin);
        }
        if (message.fundsSufficiencyLevel !== undefined) {
            obj.fundsSufficiencyLevel = Quotation.toJSON(message.fundsSufficiencyLevel);
        }
        if (message.amountOfMissingFunds !== undefined) {
            obj.amountOfMissingFunds = MoneyValue.toJSON(message.amountOfMissingFunds);
        }
        if (message.correctedMargin !== undefined) {
            obj.correctedMargin = MoneyValue.toJSON(message.correctedMargin);
        }
        return obj;
    },
};
function createBaseGetUserTariffRequest() {
    return {};
}
export const GetUserTariffRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetUserTariffRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
};
function createBaseGetUserTariffResponse() {
    return { unaryLimits: [], streamLimits: [] };
}
export const GetUserTariffResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.unaryLimits) {
            UnaryLimit.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.streamLimits) {
            StreamLimit.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetUserTariffResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.unaryLimits.push(UnaryLimit.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.streamLimits.push(StreamLimit.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            unaryLimits: globalThis.Array.isArray(object?.unaryLimits)
                ? object.unaryLimits.map((e) => UnaryLimit.fromJSON(e))
                : [],
            streamLimits: globalThis.Array.isArray(object?.streamLimits)
                ? object.streamLimits.map((e) => StreamLimit.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.unaryLimits?.length) {
            obj.unaryLimits = message.unaryLimits.map((e) => UnaryLimit.toJSON(e));
        }
        if (message.streamLimits?.length) {
            obj.streamLimits = message.streamLimits.map((e) => StreamLimit.toJSON(e));
        }
        return obj;
    },
};
function createBaseUnaryLimit() {
    return { limitPerMinute: 0, methods: [] };
}
export const UnaryLimit = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.limitPerMinute !== 0) {
            writer.uint32(8).int32(message.limitPerMinute);
        }
        for (const v of message.methods) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnaryLimit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.limitPerMinute = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.methods.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            limitPerMinute: isSet(object.limitPerMinute) ? globalThis.Number(object.limitPerMinute) : 0,
            methods: globalThis.Array.isArray(object?.methods) ? object.methods.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.limitPerMinute !== 0) {
            obj.limitPerMinute = Math.round(message.limitPerMinute);
        }
        if (message.methods?.length) {
            obj.methods = message.methods;
        }
        return obj;
    },
};
function createBaseStreamLimit() {
    return { limit: 0, streams: [], open: 0 };
}
export const StreamLimit = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.limit !== 0) {
            writer.uint32(8).int32(message.limit);
        }
        for (const v of message.streams) {
            writer.uint32(18).string(v);
        }
        if (message.open !== 0) {
            writer.uint32(24).int32(message.open);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamLimit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.streams.push(reader.string());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.open = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
            streams: globalThis.Array.isArray(object?.streams) ? object.streams.map((e) => globalThis.String(e)) : [],
            open: isSet(object.open) ? globalThis.Number(object.open) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.limit !== 0) {
            obj.limit = Math.round(message.limit);
        }
        if (message.streams?.length) {
            obj.streams = message.streams;
        }
        if (message.open !== 0) {
            obj.open = Math.round(message.open);
        }
        return obj;
    },
};
function createBaseGetInfoRequest() {
    return {};
}
export const GetInfoRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
};
function createBaseGetInfoResponse() {
    return { premStatus: false, qualStatus: false, qualifiedForWorkWith: [], tariff: "" };
}
export const GetInfoResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.premStatus === true) {
            writer.uint32(8).bool(message.premStatus);
        }
        if (message.qualStatus === true) {
            writer.uint32(16).bool(message.qualStatus);
        }
        for (const v of message.qualifiedForWorkWith) {
            writer.uint32(26).string(v);
        }
        if (message.tariff !== "") {
            writer.uint32(34).string(message.tariff);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.premStatus = reader.bool();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.qualStatus = reader.bool();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.qualifiedForWorkWith.push(reader.string());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.tariff = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            premStatus: isSet(object.premStatus) ? globalThis.Boolean(object.premStatus) : false,
            qualStatus: isSet(object.qualStatus) ? globalThis.Boolean(object.qualStatus) : false,
            qualifiedForWorkWith: globalThis.Array.isArray(object?.qualifiedForWorkWith)
                ? object.qualifiedForWorkWith.map((e) => globalThis.String(e))
                : [],
            tariff: isSet(object.tariff) ? globalThis.String(object.tariff) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.premStatus === true) {
            obj.premStatus = message.premStatus;
        }
        if (message.qualStatus === true) {
            obj.qualStatus = message.qualStatus;
        }
        if (message.qualifiedForWorkWith?.length) {
            obj.qualifiedForWorkWith = message.qualifiedForWorkWith;
        }
        if (message.tariff !== "") {
            obj.tariff = message.tariff;
        }
        return obj;
    },
};
export const UsersServiceDefinition = {
    name: "UsersService",
    fullName: "tinkoff.public.invest.api.contract.v1.UsersService",
    methods: {
        /** Получить счета пользователя. */
        getAccounts: {
            name: "GetAccounts",
            requestType: GetAccountsRequest,
            requestStream: false,
            responseType: GetAccountsResponse,
            responseStream: false,
            options: {},
        },
        /** Рассчитать маржинальные показатели по счёту. */
        getMarginAttributes: {
            name: "GetMarginAttributes",
            requestType: GetMarginAttributesRequest,
            requestStream: false,
            responseType: GetMarginAttributesResponse,
            responseStream: false,
            options: {},
        },
        /** Запросить тариф пользователя. */
        getUserTariff: {
            name: "GetUserTariff",
            requestType: GetUserTariffRequest,
            requestStream: false,
            responseType: GetUserTariffResponse,
            responseStream: false,
            options: {},
        },
        /** Получить информацию о пользователе. */
        getInfo: {
            name: "GetInfo",
            requestType: GetInfoRequest,
            requestStream: false,
            responseType: GetInfoResponse,
            responseStream: false,
            options: {},
        },
    },
};
function toTimestamp(date) {
    const seconds = date.getTime() / 1000;
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new globalThis.Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=users.js.map